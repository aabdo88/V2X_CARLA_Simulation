#  (C) Copyright 2017, 2018 Crash Avoidance Metrics Partners LLC, VSC5 Consortium
# 
#  Licensed under the Apache License, Version 2.0 (the "License");
#  you may not use this file except in compliance with the License.
#  You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
#  Unless required by applicable law or agreed to in writing, software
#  distributed under the License is distributed on an "AS IS" BASIS,
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
#  See the License for the specific language governing permissions and
#  limitations under the License.
# 
from bfkeyexp import *
from ecc import *
from implicit import *
from pkencrypt import *
from pseudosign import *

def DecryptSECR(v, c, t, nonce, ctxt, encSeed, encExp, iVal, jVal) :
    '''
    Decrypts a SignedEncryptedCertificateResponse from a pseudo cert batch file.

    v, c, t, nonce, ctxt are parsed from the EncryptedData within the response.
    encSeed, encExp correspond to the original pseudo cert provision request.
    iVal, jVal are derived from the filename i_j.

    Inputs:
    - v:            {ec256 point}   ephemeral public key of sender
    - c:            {octet string}  encrypted symmetric key
    - t:            {octet string}  authentication tag
    - nonce:        {octet string}  AES nonce
    - ctxt:         {octet string}  AES ciphertext
    - encSeed:      {long}          seed encryption key from request
    - encExp:       {long}          encryption expansion value from request
    - iVal, jVal:   {long}          i,j values for the given certificate

    Outputs:
    - ptxt:     {octet string}  OER encoded Ieee1609Dot2Data content=
                                UnsecuredData, containing an OER encoded
                                PlaintextCertificateResponse
    '''

    # butterfly expand the keys to get the encryption keypair for (i,j)
    prv = bfexpandkey(iVal, jVal, encExp, encSeed, "enc")[0]

    # convert prv key to a hex string for use below
    prvHex = '{:X}'.format(prv)

    # decrypt the ciphertext using the encrypted key
    ptxt = PKDecrypt(v, c, t, "", prvHex, nonce, ctxt)

    return ptxt.upper()



if __name__ == "__main__":

# The examples below are based on a set of sample certificates provided by GHS.
# In particular, the following files were used for the constants below:

# 02966fce6765376ea996697ae073b810ddcbc0efc72e96a509db72a12f9b71e711/security_params.txt
# 02966fce6765376ea996697ae073b810ddcbc0efc72e96a509db72a12f9b71e711/Downloads/94.zip/94_0
# 02966fce6765376ea996697ae073b810ddcbc0efc72e96a509db72a12f9b71e711/trustedcerts/PCA


# Step 1: Parameter Setup

  # In practice, these four values are generated by the EE when sending the
  # EeRaPseudonymCertProvisioningRequest. These are the parameters used to
  # butterfly expand the signing and encryption keys for pseudo certs.

  # let request = EeRaPseudonymCertProvisioningRequest

    # private key corresponding to: request.verify-key-info.seed-key
    signPrv = 0xe36fa09b763502756f2d14f83885a75f37b3238be1217b9215d411791ad6474c

    # signing expansion value: request.verify-key-info.expansion
    signExp = 0x831d918aad95432279b04e7f432b8f43

    # private key corresponding to: request.resp-enc-key-info.seed-key
    encPrv  = 0x9094af7ad265cffb6caf57700df7a6d70e29eae83c326eaae7083318ce6325e4

    # encryption expansion value: request.resp-enc-key-info.expansion
    encExp  = 0x40bf96514b66d4de792225c996b21b68

  # i,j from filename: i_j (e.g., 94_0). i,j are given in hex
    iVal = 0x94
    jVal = 0x0


# Step 2: Decrypt the SECR

  # A pseudo cert batch file extracts to a set of files, each containing an OER-encoded
  # SignedEncryptedCertificateResponse. These values were copied from the response via ASN.1 tools.
  # This message is a SignedData, signing an UnsecuredData, containing a
  # ToBeSignedEncryptedCertificateResponse, containing an EncryptedData, which decrypts to a
  # PlaintextCertificateResponse.

  # We will assume that the signature on this message is valid, and that the recipientId within
  # the message matches the same ID we derive.

  # let tbsEcr = response.content.signedData.tbsData.payload.content.unsecuredData
  #     (tbsEcr can then be interpreted as a ToBeSignedEncryptedCertificateResponse)
  # let encData = ToBeSignedEncryptedCertificateResponse.encrypted-cert.content.encryptedData

    # encData.recipients[0].encKey.eciesNistP256.v
    # NOTE: make sure v is set to the correct point type (y-0 / y-1)
    v = ECPoint("compressed-y-0","85277F54BB51CD3C4E5904F4EE56D92CF622C32C0E40B4BB125A98FD623CE317")

    # encData.recipients[0].encKey.eciesNistP256.c
    c = "BABE3D42930283127352AEE69F0697BF"

    # encData.recipients[0].encKey.eciesNistP256.t
    t = "88B0A62209A7348FF8D2A38F0A5C57B5"

    # encData.ciphertext.aes128ccm.nonce
    nonce = "216EA0440A2CE3CC69AE9B32"

    # encData.ciphertext.aes128ccm.ccmCiphertext
    ctxt = "5C4114995A1CA8FCCD82D749870D5EA90865A0FE6CE75DBDE688C07D614A7A136A716730785BD696CC66B4C315EC3FF5F1984A1BA4849A90B94F669A9BEFDC290791BDEC866CC1FED27429EAC2D6B3485CD8E47558C7015BE74935FC8A7539A4A61BE510DA2D17BB45E436B0D0917234DA0E67A94D83485B76089FB5809AC8C0E37A4C0C8E0C495AB35D5AB060F1"


  # We can now use the butterfly params with i,j to derive an ECIES key to decrypt (v,c,t),
  # which decrypts to an AES key, which we can then use to decrypt the ciphertext.
  # The included helper function does the butterfly expansion + hybrid decryption in one shot.

    print("\nDecrypting SignedEncryptedCertificateResponse...")
    ptxt = DecryptSECR(v, c, t, nonce, ctxt, encPrv, encExp, iVal, jVal)

    # If successful, ptxt should be an UnsecuredData containing PlaintextCertificateResponse
    print("Ieee1609Dot2Data, content=UnsecuredData containing PlaintextCertificateResponse:\n" + ptxt + "\n")


# Step 3: Recover the pseudo cert + signing key

  # let ptcr = ptxt.content.unsecuredData

  # These values are retrieved from the PlaintextCertificateResponse via ASN.1 tools

    # The pseudonym certificate: ptcr.implicit-butterly.certificate
    pseudoCert = "0003018027a69ece71cb778550800000942b71029c5cf41e154fcb778500011a0e13108400a983010180034801028001208000800126800081828ad4c0ecc95ce234750673d5f359b5ab36ab57312f8fac4114e9c86f8d8cdf72".upper()

    # The private reconstruction value: ptcr.implicit-butterfly.priv-key-reconstruction-s
    prvRecon = "5910C2F6230D2B9F2CD361CF185838F640F72B5EE5941520E53300A4691B35F3"


  # These are pulled out of the pseudo cert

    # pseudoCert.toBeSigned
    pseudoTbs = "50800000942B71029C5CF41E154FCB778500011A0E13108400A983010180034801028001208000800126800081828AD4C0ECC95CE234750673D5F359B5AB36AB57312F8FAC4114E9C86F8D8CDF72"

    # The public reconstruction value: pseudoCert.toBeSigned.verifyKeyIndicator.reconstructionValue
    # NOTE: Make sure correct point type is set (y-0 / y-1)
    pubRecon = ECPoint("compressed-y-0", "8AD4C0ECC95CE234750673D5F359B5AB36AB57312F8FAC4114E9C86F8D8CDF72")

  # We also need information about the PCA to reconstruct keys and verify signatures

    # The OER encoded PCA cert
    pcaCert = "8003008057C95A3362F1FC395981147063612E746573742E76327873636D732E636F6DF1FC39000219BB049086000483010380007C8001E480034801018001238003850001010100810080839CBF806B67AE4C4C4244F5214BC36822AAD5E4E8A65E6035AF4C4C24FED785B6808082D43526739665CE3D4AB90351F4BEAAB04E465622D829CB8F51FE61A71456B4188080514BB8FD14FD3977FB6C46DCD5DE07010ACD97906A2544B92E54017331CB5261443643541379EDA85B735797A84EF72F0775719B2F1BB5C35762CC2F33AF56B5"

    # PCA's public key: pcaCert.toBeSigned.verifyKeyIndicator.verificationKey
    # NOTE: Make sure correct point type is set (y-0 / y-1)
    pcaPub = ECPoint("compressed-y-0", "D43526739665CE3D4AB90351F4BEAAB04E465622D829CB8F51FE61A71456B418")

  # We now have enough information to reconstruct our private signing key

    print("Reconstructing private signing for pseudo cert %X_%X..." % (iVal,jVal))
    pseudoPrv = BFExpandAndReconstructKey(signPrv, signExp, iVal, jVal, prvRecon, pseudoTbs, pcaCert)[0]

    print(pseudoPrv)


# Step 4: Sign some data

  # The key reconstruction above should fail if we don't have a valid keypair, but we can still
  # do some tests to ensure we can sign/verify using the recovered certificate.

  # let SignedData = Ieee1609Dot2Data, content=SignedData
  # In practice, SignedData.tbsData.payload.data will be an UnsecuredData with
  #      unsecuredData.content = <UPER encoded BSM>; OR,
  #      unsecuredData.content = <OER encoded MisbehaviorReport>

    # SignedData.tbsData
    # NOTE: This is not a valid message, just a placeholder example
    tbsData = "00112233445566778899AABBCCDDEEFF"

    print("\nSigning tbsData using pseudo cert %x_%x..." % (iVal,jVal))
    r, s = PseudonymSign(tbsData, pseudoPrv, pseudoCert)[:2]

  # The signature can then be written to SignedData, along with the SignerIdentifier
    #   SignedData.signer.certificate[0] = pseudoCert; OR,
    #   SignedData.signer.digest = HashedId8(pseudoCert)
    print("Signature: ")

    # r -> SignedData.signature.ecdsaNistP256Signature.r
    print("r: (\"x-only\", " + r.output(compress=True, Ieee1609Dot2=True)[1].upper() + ")")

    # s -> SignedData.signature.ecdsaNistP256Signature.s
    print("s: " + '{:X}'.format(s))

  # Does our signature verify correctly?
    result = PseudonymVerify(r, s, tbsData, pseudoCert, pseudoTbs, pubRecon, pcaCert, pcaPub)
    print("\nSignature verifies? %r\n" % result)
